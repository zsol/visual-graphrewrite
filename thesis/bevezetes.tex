\chapter{Bevezetés}

Ebben a diplomamunkában gráfátíró rendszerekkel foglalkozunk.

Ahhoz, hogy kitûzhessük a célunkat, ismertetünk pár alapfogalmat a
gráfátíró rendszerekkel kapcsolatban.

\csillagok

A gráfátírás (\emph{graph rewriting} vagy \emph{graph transformation})
azt a folyamatot jelenti, mely során egy eredeti gráfból valamilyen
automatizmus alapján egy új gráfot állítunk elõ. Formálisan: egy
gráfátíró rendszer $p : L \rightarrow R$ alakú szabályok halmaza, ahol
$L$ a minta gráf (a szabály bal oldala), $R$ pedig a helyettesítõ gráf
(a szabály jobb oldala).

A gráfátíró rendszerek (melyeket elõször \told{\cite{interm}}+ban{}
vezettek be) jól használhatóak valamilyen számítás
modellezésére. Az ötlet az, hogy a számítás egy adott állapotát
reprezentáljuk egy gráffal. Egy adott állapotból a következõbe úgy
jutunk, ha az eredeti állapotnak megfelelõ gráfra alkalmazunk egy
szabályt, ezáltal új gráfot (állapotot) kapva. A szabály alkalmazása
úgy történik, hogy az eredeti gráfra (vagy annak részgráfjára)
illesztjük a szabály bal oldalát. Ezt a folyamatot mintaillesztésnek
hívjuk.

\begin{megj}
  Mintaillesztés közben meg kell oldanunk a részgráf
  izomorfiájának problémáját.
\end{megj}

Ezt a modellt fogjuk használni a Haskell esetében, ami egy lusta
funkcionális programozási nyelv. A lustaság ebben az esetben azt
eredményezi, hogy könnyen, elegánsan tudunk kezelni végtelen
adatszerkezeteket anélkül, hogy ehhez különösebb memória vagy
háttértár igényeket támasztanánk. A gráfátíró rendszerek segítségével
ilyen esetekben is jól tudjuk modellezni a memória- és idõigényt.

Két fõ fogalmat vezetünk be.

\begin{definicio}[Adatgráf]
  Adatgráfnak nevezzük azokat a gráfokat, melyek teljesítik a
  következõ kritériumokat:
  \begin{itemize}
    \item irányított
    \item létezik egy kitüntetett csúcs (gyökér), melybõl bármelyik
      csúcs elérhetõ
    \item minden csúcshoz hozzá van rendelve egy szimbólum
    \item egy adott csúcs kimenõ élei számozottak
  \end{itemize}
  Adatgráf esetén egy csúcs élein ezentúl a kimenõ éleket értjük.
\end{definicio}

Az egyszerûség kedvéért minden adatgráfnak definiáljuk egy úgynevezett
szöveges formáját, ami gyakorlatilag egy Haskell nyelven leírt
kifejezést jelent. Minden kifejezéshez tartozik egy olyan adatgráf,
aminek az a kifejezés a szöveges formája. Ezzel meg is teremtettük a
kapcsolatot a programszöveg és a gráfátíró rendszer között.

\begin{definicio}[Redukció]
  A gráfredukció során egy az adatgráfban található szimbólumot
  helyettesítjük egy megfelelõ átírási szabály által elõírt másik
  szimbólummal (vagy szimbólumokkal).
\end{definicio}

Az átírási szabályokat a programban található függvények definíciói
adják. Egy redukciós lépés során tehát egy függvényszimbólumot
(és argumentumait) helyettesítjük a függvény törzsével. Egy
redukciós lépés csak egyetlen függvényszimbólumot eliminál, viszont
természetesen a törzs tartalmazhat újabb függvényhívásokat.

Ezen diplomamunkához tartozó program egy Haskell nyelven íródott
programszöveget transzformál gráfátíró rendszerré, majd ebben a
gráfátíró rendszerben egy tetszõleges Haskell kifejezés átírási
lépéseit hajtja végre, illetve rajzolja ki a képernyõre. Egy további
funkcióval is rendelkezik, mellyel magát a gráfátíró rendszert
jeleníthetjük meg, pontosabban a rendszerben található szabályok jobb
oldalát. A kiválasztott funkciótól függõen a felhasználó interaktívan
lépkedhet az elsõ esetben az átírási lépések között, a másodikban
pedig a szabályok között elõre-hátra. A program célja az, hogy egy
olyan eszközt biztosítson, amivel könnyebben érthetõek lesznek
egyszerû, Haskell nyelven írt funkcionális kódok, ezáltal segíthet a
teljesítményelemzésben, illetve azoknak, akik épp ismerkednek a
funkcionális programozás rejtelmeivel.

A dolgozat hátralevõ részében elõször ismertetjük a gráfátíró
rendszerek elméleti alapjait, majd a konkrét implementációs
megfontolásokra térünk rá.

%% Local Variables:
%% coding: latin-2
%% End:

