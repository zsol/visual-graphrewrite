\chapter{Bevezetés}

Ebben a diplomamunkában gráfátíró rendszerekkel foglalkozunk.

Ahhoz, hogy kitûzhessük a célunkat, ismertetünk pár alapfogalmat a
gráfátíró rendszerekkel kapcsolatban.

\csillagok

A gráfátírás (\emph{graph rewriting} vagy \emph{graph transformation})
azt a folyamatot jelenti, mely során egy eredeti gráfból valamilyen
automatizmus alapján egy új gráfot állítunk elõ. Formálisan: egy
gráfátíró rendszer $p : L \rightarrow R$ alakú szabályok halmaza, ahol
$L$ a minta gráf (a szabály bal oldala), $R$ pedig a helyettesítõ gráf
(a szabály jobb oldala).

A gráfátíró rendszerek (melyeket elõször \told{\cite{interm}}+ban{}
vezettek be) jól használhatóak valamilyen számítás
modellezésére. Az ötlet az, hogy a számítás egy adott állapotát
reprezentáljuk egy gráffal. Egy adott állapotból a következõbe úgy
jutunk, ha az eredeti állapotnak megfelelõ gráfra alkalmazunk egy
szabályt, ezáltal új gráfot (állapotot) kapva. A szabály alkalmazása
úgy történik, hogy az eredeti gráfra (vagy annak részgráfjára)
illesztjük a szabály bal oldalát. Ezt a folyamatot mintaillesztésnek
hívjuk.

\begin{megj}
  Mintaillesztés közben meg kell oldanunk a részgráf
  izomorfiájának problémáját.
\end{megj}

Ezt a modellt fogjuk használni a Haskell esetében, ami egy lusta
funkcionális programozási nyelv. A lustaság ebben az esetben azt
eredményezi, hogy könnyen, elegánsan tudunk kezelni végtelen
adatszerkezeteket anélkül, hogy ehhez különösebb memória vagy
háttértár igényeket támasztanánk. A gráfátíró rendszerek segítségével
ilyen esetekben is jól tudjuk modellezni a memória- és idõigényt.

Két fõ fogalmat vezetünk be.

\begin{definicio}[Adatgráf]
  Adatgráfnak nevezzük azokat a gráfokat, melyek teljesítik a
  következõ kritériumokat:
  \begin{itemize}
    \item irányított
    \item létezik egy kitüntetett csúcs (gyökér), melybõl bármelyik
      csúcs elérhetõ
    \item minden csúcshoz hozzá van rendelve egy szimbólum
    \item egy adott csúcs kimenõ élei számozottak
  \end{itemize}
  Adatgráf esetén egy csúcs élein ezentúl a kimenõ éleket értjük.
\end{definicio}

Az egyszerûség kedvéért minden adatgráfnak definiáljuk egy úgynevezett
szöveges formáját, ami gyakorlatilag egy Haskell nyelven leírt
kifejezést jelent. Minden kifejezéshez tartozik egy olyan adatgráf,
aminek az a kifejezés a szöveges formája. Ezzel meg is teremtettük a
kapcsolatot a programszöveg és a gráfátíró rendszer között.

\begin{pelda}
  Vegyük a következõ Haskell kifejezést:
  \begin{lstlisting}
    l = [71, 72]
  \end{lstlisting}
  Ez definiál egy $l$ szimbólumot, melyhez egy két elemû listát köt,
  melynek elemei rendre $71$ és $72$. Ez az írásmód tulajdonképpen egy
  szintaktikus egyszerûsítése a megfelelõ listának:
  \begin{lstlisting}
    [71, 72] == 71 : 72 : []
  \end{lstlisting}
  Az egyenlõség jobb oldalán található kifejezés mutatja, hogyan
  reprezentálja a listákat a nyelv specifikációja. Két konstruktort
  figyelhetünk meg: a $(:)$  ,,listabõvítõ operátort'', mely a
  baloldali argumentumát (egy elem) a jobboldali argumentuma (egy
  lista) elé helyez; valamint a $[]$ üres lista konstruktort. A fenti
  kifejezéshez tartozó adatgráfot \aref{fig:lstdatag} ábra mutatja.
  \begin{figure}[htb]
    \begin{center}
      \caption{Egy kételemû listához tartozó adatgráf}
      \includegraphics[height=0.3\textheight]{eps/grw_5.eps}
    \end{center}
    \label{fig:lstdatag}
  \end{figure}
\end{pelda}

\begin{definicio}[Redukció]
  A gráfredukció során egy az adatgráfban található szimbólumot
  helyettesítjük egy megfelelõ átírási szabály által elõírt másik
  szimbólummal (vagy szimbólumokkal).
\end{definicio}

Az átírási szabályokat a programban található függvények definíciói
adják. Egy redukciós lépés során tehát egy függvény szimbólumot
(és argumentumait) helyettesítjük a függvény törzsével. Egy
redukciós lépés csak egyetlen függvény szimbólumot eliminál, viszont
természetesen a törzs tartalmazhat újabb függvény hívásokat.

\begin{pelda}
  Természetesen egy függvény definícióját két részre lehet bontani. A
  bal oldal (\emph{left hand side}, \emph{lhs}) megadja a függvény
  nevét, illetve az argumentumait --- a Haskell esetében mintákat,
  melyeket késõbb illeszteni lehet konkrét argumentumokra. A jobb
  oldal (\emph{right hand side}, \emph{rhs}) pedig maga a
  függvénytörzs, melyben leírjuk, hogy a jobb oldalon megadott
  mintaillesztések után a függvény szimbólumot és argumentumait milyen
  kifejezésre kell lecserélni. Ez jól megfeleltethetõ az átírási
  szabályok bal- és jobb oldalának, és valóban ez áll a definíció
  hátterében.
  A következõ egyszerû függvény a logikai \emph{és} mûveletet valósítja
  meg:
  \begin{lstlisting}
    False && _ = False
    True  && a = a
  \end{lstlisting}
  Ebbõl a kódrészletbõl két átírási szabály keletkezik --- soronként
  egy.
  \begin{figure}[htb]
    \captionsetup{position=top}
    \captionsetup[subfloat]{captionskip=-20pt}
    \begin{center}
      \subfloat[Elsõ sor]{
        \label{fig:eselso}
        \includegraphics{eps/grw_14.eps}
        \captionsetup{position=top}
      }
      \subfloat[Második sor]{
        \captionsetup{position=top}
        \label{fig:esmasodik}
        \includegraphics[height=7cm]{eps/grw_15.eps}
      }
      \vspace{28pt}
      \caption{A logikai \emph{és} két szabálya}
    \end{center}
    \label{fig:esszabaly}
  \end{figure}
  Látható, ahogy az elsõ szabályban két különbözõ csúcsba ugyanaz a
  (\emph{False}) érték íródott. Ez azt jelenti, hogy a kiértékelés
  közben kétszer tárolódik el ez az érték (egyszer a
  mintaillesztésnél, egyszer a szabály jobb oldalánál). Ezen persze
  lehet javítani Haskell-ben a következõ megoldással:
  \begin{lstlisting}
    f@False && _ = f
  \end{lstlisting}
  Itt az \emph{f} szimbólum egy referencia lesz arra a kifejezésre,
  ami illeszkedett a \emph{False} konstruktorra. Az így kialakult
  szabály hasonlít \aref{fig:esmasodik} ábrára.

  A második szabály arra mutat példát, hogy a bal oldalon kialakult
  kötéseket használhatjuk a jobb oldalon is, sõt, hatékonysági okokból
  érdemes is ezt tenni.
\end{pelda}

Ezen diplomamunkához tartozó program egy Haskell nyelven íródott
programszöveget transzformál gráfátíró rendszerré, majd ebben a
gráfátíró rendszerben egy tetszõleges Haskell kifejezés átírási
lépéseit hajtja végre, illetve rajzolja ki a képernyõre. Egy további
funkcióval is rendelkezik, mellyel magát a gráfátíró rendszert
jeleníthetjük meg, pontosabban a rendszerben található szabályok jobb
oldalát. A kiválasztott funkciótól függõen a felhasználó interaktívan
lépkedhet az elsõ esetben az átírási lépések között, a másodikban
pedig a szabályok között elõre-hátra. A program célja az, hogy egy
olyan eszközt biztosítson, amivel könnyebben érthetõek lesznek
egyszerû, Haskell nyelven írt funkcionális kódok, ezáltal segíthet a
teljesítmény elemzésben, illetve azoknak, akik épp ismerkednek a
funkcionális programozás rejtelmeivel.

A dolgozat hátralevõ részében elõször ismertetjük a gráfátíró
rendszerek elméleti alapjait, majd a konkrét implementációs
megfontolásokra térünk rá.

%% Local Variables:
%% coding: latin-2
%% End:


% LocalWords:  rewriting transformation left hand side lhs right rhs False pt
% LocalWords:  position subfloat captionskip esmasodik
