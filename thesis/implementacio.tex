\chapter{Implementáció}
\label{chap:impl}

Ebben a fejezetben a diplomamunkához tartozó program implementációs
kérdéseivel foglalkozunk.

\section{A program szerkezete}
A programot Haskell nyelven implementáltuk, mivel egyrészt magát a
forráskódot könnyen lehet feldolgozni (számos szövegfeldolgozó
könyvtárcsomag létezik ezen a nyelven; mivel a legnépszerûbb Haskell
fordítót is Haskell-ben írták, fel tudtuk használni az ebbõl származó
segédfüggvényeket a forráskód elemzéséhez), másrészt a gráfátíró
rendszer implementálása is bonyodalommentesen történt, köszönhetõen a
nyelv stílusának, mely közel áll a matematikai formalizmus nyelvéhez.

A kódot két nagy csoportra bonthatjuk: egy könyvtárcsomagra és a
felhasználói felületre. A felhasználói felület felelõs a paraméterek
megfelelõ beolvasásáért, a hibák továbbításáért a felhasználó felé,
illetve természetesen a gráfok kirajzolásáért.

\subsection{Felhasználói felület}
A felület kódja egyrészt a \emph{GraphRewrite/Main.hs} fájlban
található, másrészt a \emph{GraphRewrite/Main} könyvtár fájljaiban. A
program maga többszálú; egy szál a megjelenítésért felelõs, egy másik
pedig magát a számítást (a gráfátírást) végzi. A két szál között a
kommunikáció egy szinkronizáló (közös) változón keresztül történik,
melyet a \emph{Control.Concurrent.MVar} csomag biztosít. A gráfok
kirajzolásához a \cite[GraphViz]{graphviz} programcsomagot
használtuk.

\subsection{Könyvtárcsomag}
A könyvtárcsomag felülete a \emph{GraphRewrite.hs} fájlban található,
mely valójában csak újra exportálja a \emph{GraphRewrite/Internal}
könyvtár alatt található belsõ modulok nyilvános felületét. A
\emph{SimpleHaskell} modul egy saját, leegyszerûsített
reprezentációját adja a Haskell nyelvnek. Erre azért volt szükség,
mert a \cite[GHC]{ghc}, a nyelv egyik legnépszerûbb
fordítóprogramjának részeként szállított beolvasó könyvtárcsomag
a gráfátíró rendszerek szempontjából túl sok információt
tartalmazott. A \emph{Convert} modul feladata az iménti beolvasás
eredményét a leegyszerûsített reprezentációra fordítani. A feldolgozás
következõ fázisát a \emph{Rename} modul végzi, mely a beolvasott
program forrásában a szöveg azonosítókat kicseréli egyedi pozitív
egész számokra (például a $sin a$ kifejezésben a $sin$ függvény
helyett az $1$, az $a$ változó helyett pedig a $2$ szám azonosítót
írja) úgy, hogy közben a láthatósági szabályokat is figyelembe
veszi. Ezen ponton kész vagyunk a gráfátíró rendszer létrehozására,
melyet a \emph{RewriteApp} modul hajt végre. Maga az átíró rendszer
struktúrája és a közvetlenül hozzá tartozó segédfüggvények és -típusok
a \emph{RewriteTypes} modulban kerültek definiálásra. Az átírási
lépéseket végrehajtó függvényeket a \emph{Rewrite} modulban
definiáltuk.

A \ref{fig:arch} ábra mutatja a különbözõ modulok kapcsolatát, azt a
folyamatot, ami egy Haskell forrásfájlból gráfátíró rendszert
készít. A szaggatott vonal modulon belüli információáramlást jelent, a
többi pedig két különbözõ modul között mutatja ezt. Az \emph{AST}
mozaik szó az ,,absztrakt szintaxisfa'' (angolul \emph{Abstract Syntax
  Tree}) rövidítése, a \emph{Convert} modul ezt állítja elõ. A két
hatszöggel jelölt csúccsal jelölt mûveleteket a \emph{Rename} modul
végzi, valamint a végsõ gráfátíró rendszert a \emph{RewriteApp}
állítja elõ.

\begin{figure}[htb!]
  \begin{center}
    \includegraphics[width=16cm]{eps/arch.eps}
    \caption{A könyvtárcsomag architektúrája}
    \label{fig:arch}
  \end{center}
\end{figure}

Egy elkészült átíró rendszer segítségével hajthatunk csak végre
átírási lépéseket. Általában minden egyes kifejezéshez hozzárendelünk
egy (a természetes számokon értelmezett) leképezést, mely megadja a
kifejezésben található referenciák feloldását (ez tehát egy $g : \N
\rightarrow \text{Kifejezés}$ leképezés). Az így kialakult párt hívjuk
\emph{PointedGraph}-nak. A gráfátírást végzõ \emph{rewriteStepFine}
függvénynek így szüksége van egy \emph{RewriteSystem} és egy
\emph{PointedGraph} típusra, melyekbõl aztán elõállítja az átírási
lépéseket tartalmazó \emph{RewriteTree} fát. Azért tároljuk ezeket a
lépéseket fában és nem pedig listában, mert így átláthatóbb az átírási
lépések szerkezete; egy ág egy részkifejezés átírásának felel meg.

\section{Navigáció}

Ahhoz, hogy a programban tudjunk az egyes átírási lépések között
hatékonyan lépkedni, valahogy el kell tárolni az aktuálisan
megjelenített lépést, valamint ahhoz, hogy visszafelé is tudjunk
lépni (akár a kezdõ kifejezésig), az összeset ezen kívül is. Ez egy
tipikus esete az egy-fókuszú adatszerkezeteknek, melyhez definiálni
kell egy környezetet (\emph{Context}), és egy adott állapotot ekkor
a $(\textit{RewriteTree}, \textit{Context})$ pár
reprezentálja. A \cite{zipper} \emph{Zippers via Differentiation}
alpontja szerint a \emph{Context} típusát úgy kapjuk, ha a
\emph{RewriteTree} típusát deriváljuk.

Az alábbiakban egy a \emph{RewriteTree}-nél általánosabb fa
adatszerkezet típusát deriváljuk, melyet a következõ Haskell kóddal
írhatunk le:
\begin{lstlisting}
  data Tree a = Branch a [Tree a]
\end{lstlisting}
A típusfunktor felírásához szükségünk lesz egy szokásosan definiált
lista típusra is:
\begin{lstlisting}
  data List a = Nil | Cons a (List a)
\end{lstlisting}
Így már definiálhatjuk a funktorainkat a következõképpen:
\begin{eqnarray}
  \mathit{ListF}_AX &=& 1 + A \times X \nonumber\\
  \mathit{List} A &=& \mu X.\mathit{ListF}_AX \nonumber\\
  \mathit{TreeF}_AX &=& A \times \mu Y.\mathit{ListF}_X Y \nonumber\\
  \mathit{Tree} A &=& \mu X.\mathit{TreeF}_AX \nonumber
\end{eqnarray}
Mindenekelõtt szükségünk lesz a lista funktor deriváltjára $A$
szerint:
\begin{eqnarray}
  \partial_A(\mathit{ListF}_AX) \cong X \label{math:listderiv}
\end{eqnarray}
A fa funktor deriváltjához fel kell használnunk a következõ
(fixpontokra vonatkozó) deriválási szabályt: $\partial_X(\mu Y.F Y)
\cong \mu Y.F Y \times \partial_XF(\mu Y.F Y)$
\begin{eqnarray}
  \partial_X(\mathit{TreeF}_AX) &\cong& A \times \partial_X(\mu
  Y.\mathit{ListF}_X Y) \nonumber\\
  &\cong& A \times \mu Y.\mathit{ListF}_X Y \times
  \partial_X\mathit{ListF}_X(\mu Y.\mathit{ListF}_X Y) \nonumber
\end{eqnarray}
Ahova behelyettesítve \told\ref{math:listderiv}+t{} kapjuk a következõ
azonosságot:
$$ \partial_X(\mathit{TreeF}_AX) \cong A \times \mu Y.\mathit{ListF}_X
Y \times \mu Y.\mathit{ListF}_X Y $$
Ahol $X$ helyére $\mathit{Tree} A$-t helyettesítve:
$$ \partial\mathit{TreeF}_A(\mathit{Tree} A) \cong A \times
\mathit{List}(\mathit{Tree} A) \times \mathit{List}(\mathit{Tree}A) $$
Ahonnan \cite{zipper} szerint megkapjuk a környezetet:
$$ \mathit{Context}_{\mathit{Tree}_A} \cong \mathit{List}(A \times
\mathit{List}(\mathit{Tree} A) \times \mathit{List}(\mathit{Tree}A))$$
Ezt Haskellre fordítva, és $A$-nak a \emph{PointedGraph} típust
választva kapjuk a következõ (\emph{RewriteTypes} modulban
megtalálható) típusdefiníciót:
\begin{lstlisting}
  type Context = [RewriteBranch]
  data RewriteBranch = RewriteBranch
      { node :: PointedGraph
      , left :: [RewriteTree]
      , rght :: [RewriteTree]
      }
\end{lstlisting}
Ekkor az aktuális állapotot egy $(\mathit{RewriteTree},
\mathit{Context})$ párral ábrázoljuk. A \emph{Context}, illetve a
\emph{RewriteBranch} \emph{left} mezõje veremként mûködik, tehát az
aktuális csúcshoz legközelebbi elem kerül a lista elejére. Így amikor
mélyebbre lépünk az adatszerkezetben, akkor az elágazást hozzáfûzzük a
\emph{Context} elejéhez; balra lépés esetén a \emph{rght} komponens
elejére fûzzük (és az új aktuális elem a \emph{left} lista tetején
lévõ lesz); jobbra és felfelé lépésnél pedig szimmetrikusan. Egybõl
látszik, hogy minden mûvelet konstans lépésszámot igényel, illetve
bármilyen részfából kiindulva a négy elemi lépéssel (le, balra,
jobbra, fel) bármelyik részfába el tudunk jutni. Ez volt a célunk az
adatstruktúra bevezetésével.

%% Local Variables:
%% coding: latin-2
%% End:

% LocalWords:  GraphRewrite GraphViz hs Internal SimpleHaskell GHC Convert Tree
% LocalWords:  Rename RewriteApp RewriteTypes Rewrite Abstract Syntax Context
% LocalWords:  PointedGraph rewriteStepFine RewriteSystem RewriteTree Zippers
% LocalWords:  via Differentiation nél Branch List ListF AX TreeF XF type left
% LocalWords:  RewriteBranch rght
