\chapter{Elméleti alapok}

Ebben a fejezetben a gráfátíró rendszerek elméleti alapjaival
foglalkozunk. A formális definíciókhoz szükséges szintaktika
az egyszerûség és érthetõség kedvéért megegyezik a \cite{cleanbook}
jelöléseivel.

\section{Adatgráfok}

A bevezetõben tárgyalt definíciója az adatgráfoknak egy jó képet ad
arról, hogy miért is fontos ez a fogalom. Ebben a pontban egy pontos,
matematikailag precíz definíciót adunk rájuk, megadjuk a kanonikus
alakjukat, egy rövidített leírási formát, illetve egyéb fontos
tulajdonságaikat.

Az egyik fõ cél az adatgráfok definíciójánál, hogy képesek legyenek
reprezentálni a bevezetõ utolsó példájában leírt referencia
konstrukciót. Ez azért hasznos, hogy el tudjuk kerülni egy adott
számítás többszöri kiértékelését, és a már esetleg kiszámolt eredményt
újra fel tudjuk használni. Ezt a technikát a számítások megosztásának
(\emph{sharing}) hívjuk.

\subsection{Szintaxis}

Egy gráfátíró rendszerben az adatgráfokat kétféleképpen írhatjuk le:
kanonikus formában és rövidített formában. Ez utóbbi eset lényege,
hogy nem kell teljesen specifikálni a gráf struktúráját, épp csak
annyit, hogy egyértelmûen ki lehessen következtetni azt a leírásból. A
kanonikus forma esetében ezzel ellentétben az egész struktúrát
részletesen specifikálni kell. Általában a rövidített formát
használjuk az átláthatósága miatt. Fontos megjegyezni, hogy a
rövidített leírásból természetesen elõállítható a kanonikus alak,
ekkor pedig a két leírás pontosan ugyanazt az adatgráfot jelöli, tehát
az egyiket minden további nélkül lehet használni a másik helyett.

A gráf specifikációjához minden esetben szükségünk lesz egy konstans
szimbólumokból (nem üres sztringek, melyek nagybetûvel kezdõdnek)
álló, valamint egy csúcs azonosítókból (kisbetûvel kezdõdõ nem üres
sztringek) és csúcs konstansokból (a ,,@'' kukac karakterrel kezdõdõ
sztringek) álló halmazra.

\subsubsection{Kanonikus alak}

Egy adatgráf kanonikus alakját a következõ szintaxissal definiáljuk:

\begin{align*}
  \tt{Graph}   &= \tt{NodeDef} \hogy \tt{NodeDef} \lit{,} \tt{Graph} \\
  \tt{NodeDef} &= \tt{Nodeid} \lit{:} \tt{Node} \\
  \tt{Node}    &= \tt{Symbol} \{\tt{Arg}\} \hogy \tt{EmptyNode} \\
  \tt{Symbol}  &= \predef{Constant} \\
  \tt{Arg}     &= \tt{Nodeid} \\
  \tt{Nodeid}  &= \predef{NodeidVariable} \hogy \predef{NodeidConstant} \\
  \tt{EmptyNode} &= \lit{$\mathbf{\bot}$}
\end{align*}

Egy adatgráf tehát csúcs definíciók (\tt{NodeDef}) egy halmaza. A
gráfban minden csúcshoz tartozik egy egyedi azonosító (\tt{Nodeid}),
mely vagy ,,@''-cal kezdõdik (\predef{NodeidConstant} -- konstans),
vagy kisbetûvel (\predef{NodeidVariable} -- változó). Egy csúcs
definíciójához (\tt{NodeDef}) kell egy ilyen csúcs azonosító, majd
egy ,,:'' karakter után következik a csúcs leírása
(\tt{Node}). Minden csúcshoz tartozik egy konstans szimbólum
(\tt{Symbol}), melynek esetleg argumentumai (\tt{Arg})
lehetnek. Ezek az argumentumok tulajdonképpen csúcs azonosítók, melyek
definiálják az éleket a gráf ábrázolt formájában.

\begin{pelda}
  \Aref{fig:lstdatag}. ábrán található adatgráf kanonikus alakja (a
  $(:)$ konstruktornak most a két paraméteres \con{Cons}, a $[]$
  konstruktornak pedig a \con{Nil} felel meg):

  \begin{canonDG}
      \cn{1} & \con{Cons} \cn{2} \cn{3}, \\
      \cn{2} & 71, \\
      \cn{3} & \con{Cons} \cn{4} \cn{5}, \\
      \cn{4} & 72, \\
      \cn{5} & \con{Nil} \\
  \end{canonDG}

  Itt tehát nincsenek változó csúcs azonosítók, csak konstansok (\cn{1}
  \ldots \cn{5}), valamint a konstans szimbólumok a következõk:
  \con{Cons}, 71, 72, \con{Nil}.
\end{pelda}

\subsection{Szemantika}

Az adatgráfok szemantikáját a kanonikus alakjuk figyelembevételével,
azok alapján fogjuk megadni.

Minden adatgráfnak létezik egy kitüntetett csúcsa, melyet a gráf
\emph{gyökeré}nek hívunk. A kanonikus alakban mindig ezt a csúcsot
soroljuk fel elõször. Egy adatgráf \emph{részgráf}jának kanonikus
alakja az eredeti gráf kanonikus alakjában található csúcshalmaz
részhalmazából áll. Egy \emph{út} a gráfban olyan csúcs azonosítók
sorozata, melyben az elsõ kivételével minden azonosító a közvetlenül
megelõzõ azonosítóhoz tartozó csúcs egyik argumentuma. Az út $A$-ból
$B$-be megy, ha $A$ azonosítója az elsõ, $B$ azonosítója pedig az
utolsó a sorozatban. A gráfban \emph{kör}nek hívjuk azokat az utakat,
melyeknek ugyanaz az elsõ és az utolsó csúcs azonosítójuk. A gráf
körmentes, ha nincs benne kör. Egy $B$ csúcs \emph{elérhetõ} $A$-ból,
ha létezik a gráfban út $A$-ból $B$-be. Ha minden csúcs elérhetõ a
gyökérbõl, akkor a gráf \emph{összefüggõ}. Egy adatgráfot
\emph{zárt}nak hívunk, ha nincs benne változó csúcs azonosító,
egyébként \emph{nyílt}nak. Egy gráf $n$ \emph{csúcstól kezdõdõ
  részgráfja} az a $g$ összefüggõ részgráf, melynek gyökere $n$, és
tartalmazza mindazokat a csúcsokat, melyek elérhetõek $n$-bõl.

\begin{megj}
  Tartsuk szem elõtt, hogy az adatgráfoknál egy úthoz tartozik annak
  egy irányítása is, tehát a köröknél, illetve az összefüggõségnél is
  figyelembe kell venni ezt az irányítást. Ez a fogalomrendszer nagyon
  hasonlít az irányított gráfoknál szokásoshoz, tulajdonképpen itt is
  errõl van szó, mint azt a bevezetõben említettük.
  Megjegyzendõ továbbá, hogy gráfátíró rendszerekben az összes gráf,
  beleértve a szabályokat is, mindig összefüggõ.
\end{megj}

\begin{pelda}
 \Aref{fig:lstdatag}. ábrán látható adatgráf például összefüggõ, de
 körmentes és zárt.

 \begin{figure}[htb]
   \begin{center}
     \caption{Egy végtelen hosszú, végtelenül egyszerû lista
       adatgráfja \label{fig:inflist}}
     \includegraphics[height=0.3\textheight]{eps/grw_new_28.eps}
   \end{center}
 \end{figure}
 \Aref{fig:inflist}. ábrán található adatgráf a végtelen hosszú, csupa
 tizenegyeseket tartalmazó listához tartozik. Kanonikus alakja:

 \begin{canonDG}
   \cn{1} & \con{Cons} \cn{2} \cn{1}, \\
   \cn{2} & 11
 \end{canonDG}

 Ez a gráf látható módon
 véges (mint minden adatgráf), zárt, összefüggõ, és tartalmaz egy kört
 (tehát hurokéleket természetesen megengedünk). Ebbõl a példából is
 látszik a gráfátíró rendszerek (és azon belül egyelõre az adatgráfok)
 kifejezõereje.
\end{pelda}

\begin{figure}[bh]
  \begin{center}
    \caption{Ekvivalens gráfok közti izomorfizmus \label{fig:grafekvizo}}
    \includegraphics[width=14cm]{eps/graf_ekv_izo.eps}
  \end{center}
\end{figure}

Két zárt gráfot \emph{ekvivalens}nek nevezünk, ha a csúcs
azonosítóktól eltekintve azonosak. Ez azt jelenti, hogy a két gráfnak
ugyanaz a struktúrája, és a megfelelõ csúcsok ugyanazokat a
szimbólumokat tartalmazzák. Formálisan, létezik egy $\varphi :
\text{NodeidConstant} \rightarrow \text{NodeidConstant}$ bijekció,
melyet ha alkalmazunk az egyik gráf kanonikus alakjában található
csúcs azonosítókra, akkor a másik gráf kanonikus alakját
kapjuk. Figyelembe véve azt, hogy az adatgráf és a kanonikus alakja
között is megadható egy bijekció, ebbõl következik, hogy ha két gráf
ekvivalens, akkor létezik köztük gyökértartó izomorfizmus. Ezt a
gondolatmenetet vázolja \aref{fig:grafekvizo}. ábra.

\section{Átíró rendszerek}

Egy gráfátíró rendszer lényege az, hogy jól definiált módon tudjunk
adatgráfokat manipulálni. A rendszer átírási szabályok halmaza,
melyeket hasonlóan fogunk megközelíteni, mint fentebb az adatgráfokat:
elõször definiáljuk a kanonikus alakjukat, ezzel szintaxist adva a
gráfátíró rendszereknek, majd megadjuk a hozzájuk tartozó szemantikát.

\subsection{Szintaxis}

Ebben az alpontban megadjuk a gráfátíró rendszerek kanonikus alakját,
majd egy példával rámutatunk, hogy mennyire kényelmetlen ebben a
formában kezelni azokat, úgyhogy megadunk egy rövidített formát is.

\subsubsection{Kanonikus alak}

A gráfátíró rendszerek szintaxisa tehát a következõképpen írható le:

\begin{align*}
  \tt{CanonicalGRS} &= \tt{Rule} \hogy \tt{Rule} \tt{CanonicalGRS}\\
  \tt{Rule} &= \tt{RedexPattern} \lit{$\rightarrow$} \{\tt{Contractum}\} \tt{Redirection} \\
  \tt{Contractum} &= \tt{ContractumPattern} \\
  &\hogy \tt{ContractumPattern} \lit{,} \tt{Contractum} \\
  \tt{RedexPattern} &= \predef{Graph} \\
  \tt{ContractumPattern} &= \predef{Graph} \\
  \tt{Redirection} &= \predef{Nodeid} \lit{$\mathbf{\leftarrow}$} \predef{Nodeid}
\end{align*}
Ahol a \predef{Nodeid} és a \predef{Graph} definíciója az adatgráfoknál
megadottal egyezik meg. A fenti definícióból is látszik, hogy a
szabályok az $r : \alpha_r \rightarrow \beta_r, \varphi_r$ alakot
követik, ahol $\beta_r$ opcionális. Ebben a jelölésben az $\alpha_r$-t
nevezik \emph{redex mintá}nak (ami a \emph{reducible expression}, azaz
 redukálható kifejezés, angol szófordulatból származik)
 a nem kötelezõ $\beta_r$ neve
\emph{csere minta}\footnote{A táblázatokban a csere minta angol
  megfelelõje, a contractum pattern szerepel}, a $\varphi_r$ pedig az
átirányítás vagy \emph{redirekció}.

Egy szabályban minden csúcs azonosító legfeljebb egyszer lehet
definiálva, illetve a jobb oldalon szereplõ azonosítókhoz kell
tartozzon ugyanezen a jobb oldalon definíció vagy szerepelniük kell a
bal oldalon. A redirekció bal oldalán található azonosítónak mindig
meg kell egyeznie a redex minta gyökerével (pontosabban annak
azonosítójával), a jobb oldali csúcs azonosító pedig vagy a csere
minta gyökere, vagy egy olyan azonosító, ami szerepel a redex
mintában.

Az elsõ szimbólumot a redex mintában \emph{függvény szimbólum}nak
hívjuk. Az a szimbólum, mely egyik minta elsõ elemeként se szerepel, a
\emph{konstruktor szimbólum}. Természetesen függvény szimbólumok nem
csak a minta fejében szerepelhetnek, hanem bárhol máshol a mintában.

\begin{pelda}
  A következõ pár sor Haskell kód definiál egy olyan függvényt,
  melynek neve \emph{head}, és
  egy lista elsõ elemét adja vissza\footnote{Figyeljük meg, hogy üres
    listára nincs definiálva a \emph{head} függvény. Ez nem probléma
    egészen addig, amíg üres listára nem próbáljuk
    illeszteni. Haskell-ben ekkor egy programhiba üzenetet kapunk, az
    elméletben viszont egyszerûen nem illeszkedik ilyen esetben a
    szabály}, egy definíció szerint (a szokásos módon) rekurzióval
  megvalósított faktoriális függvényt, illetve egy kezdõszimbólumot,
  mely a késõbbiekben a gráfátírás kezdõpontja lesz.
  \begin{lstlisting}
    head (a:b) = a
    fact 0 = 1
    fact n = n * fact (n-1)

    start = fact (head [1000])
  \end{lstlisting}
  Ebbõl a pár sorból felírhatunk egy olyan gráfátíró rendszert,
  melyben négy szabály van (minden sornak megfelel egy, figyeljük meg,
  hogy a faktoriális függvényhez tartozó két sorból is két külön
  szabály keletkezik). Ennek a rendszernek a kanonikus alakja a következõ:
  \begin{canonGRS}
    r:~\con{Head}~x, \n
    x:~\con{Cons}~a~b & \rightarrow & r \leftarrow a \n
    \n
    r:~\con{Fact}~x, \n
    x:~0 & \rightarrow & r':~1, ~ r \leftarrow r' \n
    \n
    r:~\con{Fact}~n & \rightarrow & r':~*~n~u, \n
    & & u:~\con{Fact}~v, \n
    & & v:~-~n~w, \n
    & & w:~1, \n
    & & r \leftarrow r' \n
    \n
    r:~\con{Start} & \rightarrow & r':~\con{Fact}~a,\n
    & & a:~\con{Head}~b, \n
    & & b:~\con{Cons}~c~d,\n
    & & c:~1000,\n
    & & d:~\con{Nil} \n
    & & r \leftarrow r' \n
  \end{canonGRS}
\end{pelda}

\subsubsection{Rövidített alak}

Mint a fenti példákból látható, az adatgráfok és a gráfátíró
rendszerek kanonikus alakját nehézkes olvasni, bonyolultabb esetekben
sok benne a redundáns információ. Ez adja a motivációt ahhoz, hogy
definiáljuk ezeknek egy úgynevezett rövidített alakját. Ebbõl a
rövidített alakból mindig automatikusan meghatározható egy kanonikus
alak mind a gráfok, mind az átíró rendszerek esetében.

\begin{align*}
  \tt{GraphRewriteSystem} &= \tt{Rule} \hogy \tt{Rule} \tt{GraphRewriteSystem} \\
  \tt{Rule} &= \tt{RedexPattern} \lit{$\mathbf{\rightarrow}$} \tt{ContractumPattern} \{\lit{,} \tt{Redirection}\} \\
  &\hogy \tt{RedexPattern} \lit{$\mathbf{\rightarrow}$} \tt{Redirection} \\
  \tt{RedexPattern} &= \tt{Graph} \\
  \tt{ContractumPattern} &= \tt{Graph} \\
  \tt{Redirection} &= \tt{Nodeid} \lit{$\mathbf{\leftarrow}$} \tt{Nodeid} \hogy \tt{Nodeid} \\
  \tt{Graph} &= \{\tt{Nodeid} \lit{:}\} \tt{Node} \hogy \{\tt{Nodeid} \lit{:}\} \tt{Node} \lit{,} \tt{Graph} \\
  \tt{Nodeid} &= NodeidVariable \hogy NodeidConstant \\
  \tt{Node} &= \tt{Symbol} \{\tt{Arg}\} \hogy \tt{EmptyNode} \\
  \tt{Symbol} &= Constant \\
  \tt{Arg} &= \tt{Nodeid} \hogy \{\tt{Nodeid} \lit{,}\} \tt{Symbol} \hogy \{\tt{Nodeid} \lit{,}\} \lit{(} \tt{Node} \lit{)} \\
  \tt{NodeDef} &= \tt{Nodeid} \lit{:} \tt{Node} \\
  \tt{EmptyNode} &= \lit{$\mathbf{\bot}$}
\end{align*}

\begin{pelda}
  Az elõzõ példa gráfátíró rendszer most rövidített alakban:

  \begin{shorthand}
    \con{Head} (\con{Cons} $a$ $b$) & $a$ \\
    \nl
    \con{Fact} 0 & 1 \\
    \con{Fact} $n$ & $*$ $n$ (\con{Fact} ($-$ $n$ 1)) \\
    \nl
    \con{Start} & \con{Fact} (\con{Head} (\con{Cons} 1000 \con{Nil}))
  \end{shorthand}

\end{pelda}

Általában ezt a jobban olvasható alakot használják a számítások
megadására, mivel szemantikusan ugyanazokat a szabályokat és gráfokat
írja le, mint a megfelelõ kanonikus alak, sõt, két egyszerû
automatizálható transzformációval meg is kaphatjuk a rövidített
alakból a kanonikusat. További elõnye ennek a rövidítésnek, hogy jól
le lehet vele írni az átírás közben történõ gráf redukálást. A
transzformációs lépéseket röviden felvázoljuk, a részleteket az
olvasóra bízzuk, de megtalálható a \cite{cleanbook} 162. és
163. oldalán is.

\begin{enumerate}
  \item Beágyazott csúcs definíciók kiküszöbölése és csúcs azonosítók
    nevesítése. A kanonikus formában nem engedtük meg a beágyazott
    csúcs definíciókat, azokat explicite ki kellett írni, és nevet
    adni nekik. Ez az egyik legnagyobb különbség a két alak között,
    fõleg ezen múlik az olvashatóság.
  \item A redirekció megadása. A redex minta gyökerét vagy a
    csere minta gyökerére irányítjuk, vagy egy csúcsos jobb oldal
    esetén az egyetlen csúcs azonosítóra.
\end{enumerate}

\subsection{Szemantika}

A gráfátíró rendszerekben található minták nyílt gráfok, tehát
mindegyikben mindig létezik legalább egy változó csúcs azonosító. Ez
igaz a redex illetve a csere mintákra is. A redirekció azt
definiálja, hogy melyik csúcsba menõ éleket melyikbe kell átirányítani
a szabály alkalmazása során. Ez tehát azt jelenti, hogy a
$\rightarrow$ bal oldalán levõ csúcs azonosítónak megfelelõ csúcsba
mutató éleket a szabály alkalmazása során a $\rightarrow$ jobb oldalán
található azonosítónak megfelelõ csúcsba irányítjuk.

A továbbiakban jelöljön $\gamma$ egy adatgráfot, $\rho$ pedig egy
átírási rendszert. Elõször részletesen tárgyaljuk a redex mintákat és
az illeszkedés fogalmát, majd rátérünk a gráfátírás menetére.

\subsubsection{Redexek}

Ahogy a korábban bemutatott gráfátíró rendszerek kanonikus
szintaxisából is látszik, a redex minták
szintaktikusan ekvivalensek az adatgráfokkal. Egy különbséget viszont
már fentebb is említettünk: a minták csak konstans szimbólumokból és
változó csúcs azonosítókból állnak. Egy redex minta \emph{példányá}nak
hívjuk az adatgráfnak azt a részgráfját, melyre létezik egy olyan
leképezés a mintáról, ami a konstans szimbólumokra megszorítva
identitás, és a csúcsok struktúráját megtartja. Ezt a példányt más
néven a redex mintához tartozó \emph{redex}nek is nevezzük. Ebben az
esetben azt mondjuk, hogy a redex minta és a megfelelõ átírási szabály
\emph{illeszkedik} a redexre. Megjegyezzük, hogy az a tény egy adatgráf
részgráfja redex-e vagy sem, attól függ, milyen átírási rendszerrel
együtt vizsgáljuk a gráfot.

Az illeszkedés fogalmának formális bevezetéséhez definiálnunk kell még
pár fogalmat. Legyen $\IS$ (konstans) szimbólumok egy halmaza, $\IN$
a csúcs azonosítók halmaza és $\IC$ egy $\IN \rightarrow \IS \times
\IN^*$ függvény. Ekkor $\IC$ egy adatgráfot ír le $\IS$ és $\IN$
felett. Minden $\gamma$ adatgráfra egyértelmûen létezik egy ilyen
függvény, melyet jelöljünk $\IC_\gamma$-val. Legyen $\pi$ egy redex
minta a $\rho$-val jelölt átírási szabályok egyikében, és $\mu$ egy
leképezés a $\pi$-ben található változó csúcs azonosítókról a $\gamma$
adatgráfban található konstans csúcs azonosítókra úgy, hogy $\mu$
megtartja a csúcsszerkezetet. Ez azt jelenti, hogy minden $x$
csúcs azonosítóra $\pi$-bõl, melyre $\IC_\pi(x)=\text{S} x_1 x_2 \dots
x_n$, igaz a következõ: $\IC_\gamma(\mu(x))=\text{S} \mu(x_1) \mu(x_2)
\dots \mu(x_n)$.

\begin{megj}
  Egy adott $\gamma$ adatgráf kanonikus alakját megkapjuk, ha
  kifejtjük a hozzá tartozó $\IC_\gamma$ függvény hozzárendelési
  szabályait.
\end{megj}

\begin{pelda}
  Az elõzõ (faktoriálisos) példában leírt gráfátíró rendszert
  figyelembe véve, nézzük a következõ kifejezéshez tartozó adatgráfot:
  \begin{lstlisting}
    head [[36]]
  \end{lstlisting}
  \begin{canonDG}
    \cn{1} & \con{Head} \cn{2}, \\
    \cn{2} & \con{Cons} \cn{3} \cn{4}, \\
    \cn{3} & \con{Cons} \cn{5} \cn{4}, \\
    \cn{4} & \con{Nil}, \\
    \cn{5} & 36
  \end{canonDG}
  \begin{figure}[htb]
    \begin{center}
      \caption{Listák listájának a fejeleme \label{fig:headlistlist}}
      \includegraphics[height=0.3\textheight]{eps/headlistlist.eps}
    \end{center}
  \end{figure}

  Ebben az esetben a $\mu$ leképezés a következõ módon írható: $\mu(r)
  = \con{@1}$, $\mu(x) = \con{@2}$, $\mu(a) = \con{@3}$, $\mu(b) =
  \con{@4}$.
\end{pelda}

\subsubsection{Gráfátírás}

A gráfátírás megkezdése elõtt célszerû
megállapodni egy fix kiinduló gráfban, ahonnan indítjuk az átírási
lépéseket. Ez a kiinduló gráf tartalmaz egy gyökér csúcsot, mely az
egész átírási folyamat alatt az adatgráf gyökere marad, illetve egy
élet, amely a ténylegesen átírandó gráf gyökerére mutat. Ezt a csúcsot
hívjuk startcsúcsnak. A startcsúcs megkövetelése nem nagy megszorítás,
hiszen az átírási szabályok közé mindig felvehetünk egy speciális
kezdõ szabályt, mely erre a startcsúcsra mutató élet átirányítja a
ténylegesen átírandó gráfra. Az egyszerûség kedvéért azonban ezt a
kezdõ szabályt mindig kihagyjuk a példa leírásokból, és a kívánt
gráfot közvetlenül adjuk meg.

Az átírási lépések célja, hogy az eredeti adatgráfból és a
\emph{segédgráfból} egy újat építsünk az élek
átirányításának segítségével. Erre a segédgráfra csak akkor van
szükségünk, amikor az illeszkedõ szabály jobb oldalán megadtunk
csere mintát. Precízebben lépésekbe foglalva:

\begin{enumerate}
  \item \textbf{Illesztés.} Válasszunk ki egy redexet a hozzá illeszkedõ
    szabállyal és a $\mu$ leképezéssel.
  \item \textbf{Csere.} Építsük fel a segédgráfot a következõképpen
    (amennyiben az illeszkedõ szabály jobb oldalán található
    csere minta):
    \begin{enumerate}
      \item Generáljunk új egyedi konstans csúcs azonosítókat (a
        $\gamma$-ban találhatóktól különbözõket) minden változó csúcs
        azonosító definícióhoz a csere mintából. Az így kialakult
        változó $\rightarrow$ konstans leképezés legyen $\mu'$. Ekkor
        $\mu'$ értékkészlete tartalmazza az átírás során újonnan
        létrejött csúcsok azonosítóit.
      \item Legyen $\mu'' = \mu \cup \mu'$. Alkalmazzuk $\mu''$-t a
        csere mintában található csúcs azonosítókra, így megkapva
        a $\kappa$ segédgráfot.
    \end{enumerate}
    Amennyiben a csere minta nincs megadva, akkor $\kappa$ üres.
  \item \textbf{Építés.} Legyen az új gráfunk $\gamma' = \gamma \cup \kappa$.
  \item \textbf{Átirányítás.} A redirekció egy szabályban az $r \rightarrow n$
    alakot ölti, ahol $r$ a redex minta gyökere. Ebben a lépésben
    minden élet, ami $r$-be mutat, átirányítunk $n$-be. Ez a
    szintaktikus reprezentációban azt jelenti, hogy a $\gamma'$ minden
    csúcs definíciójában minden \textbf{argumentumként} megjelenõ @R
    konstans csúcs azonosítót kicserélünk @N-re, ahol $\mu(r) =
    \text{@R}$ és $\mu(n) = \text{@N}$. Az így kapott gráfot
    jelöljük $\eta$-val.
  \item \textbf{Szemétgyûjtés.} Az elõzõ lépésben megkapott $\eta$ nem
    biztos, hogy összefüggõ. Ennek biztosítása a következõképpen
    történik: minden csúcs, ami nem elérhetõ az eredeti $\gamma$ gráf
    gyökerébõl, törlésre kerül a hozzá tartozó élekkel együtt. Így
    tehát az eredmény gráfba csak azokat a csúcsokat értjük bele, amik
    továbbra is elérhetõek maradtak az eredeti gyökérbõl a fenti
    lépések végrehajtása után.
\end{enumerate}

\begin{megj}
  Mivel a redex gyökere igen fontos szerepet tölt be az átírási
  folyamatban, néha pongyolán egy csúcs átírásáról vagy redukálásáról
  beszélünk, miközben annak a gráfnak a redukálására gondolunk,
  amelynek gyökere a szóban forgó csúcs.
\end{megj}

A következõ példában részletesen bemutatunk egy nagyon egyszerû
esetet:

\begin{pelda}
  Amint azt fent írtuk, a legelsõ lépésben a $\gamma$ alakja mindig
  ez:

  \begin{canonDG}
    \cn{Root} & \con{Graph} \cn{StartNode}, \\
    \cn{StartNode} & \con{Start}
  \end{canonDG}

  A következõ Haskell kód lesz az átírási környezetünk (a fenti
  $\gamma$ miatt definiálnunk kell egy ``start'' nevû csúcsot, ahonnan
  indulni fog az átírás):

  \begin{lstlisting}
    -- data Nat = Zero | Succ Nat
    add Zero z = z
    add (Succ a) z = Succ (add a z)

    start = add (Succ Zero) Zero
    -- start == Succ Zero
  \end{lstlisting}

  Az ehhez tartozó $\rho$ átírási szabályok halmaza a következõ:

  \begin{eqnarray} %Ez sajnos spec eset a szamozas miatt!
    x: \text{Add}~y~z, \n
    y: \text{Zero} & \hspace{0.5cm}\rightarrow\hspace{0.5cm} & x \leftarrow z \label{tab:rule1}\\
    \n
    x: \text{Add}~y~z, \n
    y: \text{Succ}~a &\hspace{0.5cm}\rightarrow\hspace{0.5cm}& m: \text{Succ}~n, \n
    & & n: \text{Add}~a~z, \n
    & & x \leftarrow m \label{tab:rule2}\\
    \n
    x: \text{Start} &\hspace{0.5cm}\rightarrow\hspace{0.5cm}& m: \text{Add}~n~o, \n
    & & n: \text{Succ}~o, \n
    & & o: \text{Zero}, \n
    & & x \leftarrow m \label{tab:rule3}
  \end{eqnarray}

  Az elsõ redukciós lépés közben a következõk történnek:
  \begin{enumerate}
    \item \textbf{Illesztés.} Az egyetlen szabály, amelyik illeszkedik
      a start csúcsra \aref{tab:rule3}, az illesztéshez tartozó
      leképezés pedig $\mu(x) = \text{@StartNode}$.
    \item \textbf{Csere.} Az új generált azonosítók és a hozzájuk
      tartozó leképezés: $\mu'(m) = @M$, $\mu'(n) = @N'$, $\mu'(o) =
      @O$. A $\mu''$ alkalmazása nincs hatással a csere mintára,
      mivel $x$ nem fordul benne elõ. A $\kappa$ tehát:

      \begin{canonDG}
        \cn{M} & \con{Add} \cn{N} \cn{O}, \\
        \cn{N} & \con{Succ} \cn{O}, \\
        \cn{O} & \con{Zero}
      \end{canonDG}
    \item \textbf{Építés.} A $\gamma'$ a következõképpen írható:

      \begin{canonDG}
        \cn{Root} & \con{Graph} \cn{StartNode}, \\
        \cn{StartNode} & \con{Start}, \\
        \cn{M} & \con{Add} \cn{N} \cn{O}, \\
        \cn{N} & \con{Succ} \cn{O}, \\
        \cn{O} & \con{Zero}
      \end{canonDG}
    \item \textbf{Átirányítás.} Az átirányítás során minden
      argumentumként elõforduló @StartNode lecserélõdik @M-re. Az
      ennek eredményeképpen születõ $\eta$ (melyet \aref{fig:rwrredir}.
      ábra is mutat):

      \begin{canonDG}
        \cn{Root} & \con{Graph} \cn{a}, \\
        \cn{StartNode} & \con{Start}, \\
        \cn{M} & \con{Add} \cn{N} \cn{O}, \\
        \cn{N} & \con{Succ} \cn{O}, \\
        \cn{O} & \con{Zero}
      \end{canonDG}
    \item \textbf{Szemétgyûjtés.} Mivel a \cn{StartNode} csúcs nem érhetõ
      el a gyökérbõl, így kitöröljük $\eta$-ból.
  \end{enumerate}

  \begin{figure}[htb]
    \begin{center}
      \caption{Az átirányítás után létrejött $\eta$ \label{fig:rwrredir}}
      \includegraphics[height=0.3\textheight]{eps/rwr_redir.eps}
    \end{center}
  \end{figure}

  Ezzel véget ért egyetlen átírási lépés. Az eredmény gráfban még
  található redex, így a folyamat folytatódhat még két lépésen
  keresztül, amikor is megkapjuk a végeredményt, melyben már nincs
  redex:

  \begin{tabular}{l@{:\hspace{0.5cm}}l}
    \cn{Root} & \con{Graph} \cn{P}, \\
    \cn{O} & \con{Zero}, \\
    \cn{P} & \con{Succ} \cn{C}
  \end{tabular}
\end{pelda}

\subsubsection{$\delta$-szabályok}

Ahogy a $\lambda$-kalkulusban és a term átíró rendszereknél, gráfoknál
is létezhetnek kívülrõl definiált függvények és konstansok. Az ilyen
külsõleg definiált szabályokat hívjuk $\delta$-szabályoknak vagy
\emph{$\delta$-függvény}eknek. Ilyen $\delta$-függvényeket implicit
módon eddig is használtunk, például az összeadás és a kivonás
alkalmazásánál. Ha egy ilyen külsõleg definiált függvényt alkalmazzuk
annyi argumentumra, amennyit ``vár'', az ennek megfelelõ
részkifejezést \emph{$\delta$-redex}nek hívjuk. Amikor az alkalmazást
elvégezzük, akkor egy \emph{$\delta$-redukciós lépés}t hajtunk
végre. Egy $\delta$-függvény argumentumainak megfelelõ típusúaknak és
megfelelõ mennyiségûeknek kell lenniük, különben a részkifejezés még
nem $\delta$-redex. Ebbõl következik, hogy ilyen esetben a függvény
argumentumait kell elõször redukálni a függvény alkalmazása elõtt.

\begin{megj}
  A $\delta$-függvényeket bele lehetne építeni az átírási szabályokba,
  általában sokkal kényelmesebb feltételezni a meglétüket, nem is
  beszélve az olvashatóságról. Természetesen csak akkor célszerû ilyet
  csinálni, amikor jól ismert függvényekrõl van szó, melyeknek
  triviális az implementációja.
\end{megj}

\subsubsection{Normál formák}

Egyetlen redukciót általában redukciós lépésnek (vagy átírási
lépésnek) hívunk. Ha $\gamma_1$ valamilyen redukciós lépéssel
$\gamma_2$-vé alakítható, akkor ezt így írjuk: $\gamma_1 \rightarrow
\gamma_2$.  Egy \emph{redukciós sorozat} egy nulla vagy több
elembõl álló redukciós lépésekbõl álló sorozatot nevezünk, melyben
igaz az, hogy ha az $i$. lépés a $\gamma_{i-1} \rightarrow \gamma_i$
redukciót valósítja meg, akkor az $i+1$. lépés a $\gamma_i \rightarrow
\gamma_{i+1}$-et. Ha létezik olyan redukciós sorozat, mely
$\gamma_1$-bõl $\gamma_2$-t állítja elõ, akkor $\gamma_2$-t $\gamma_1$
\emph{redukáltjá}nak nevezzük, és ezt a tényt így jelöljük: $\gamma_1
\rastar \gamma_2$. A $\rastar$ tehát a $\rightarrow$ tranzitív,
reflexív lezártja.

\begin{megj}
  A $\rastar$ fenti definíciója miatt elképzelhetõ az, hogy $\gamma
  \rastar \eta$, de $\gamma \not\rightarrow \eta$. Ez csak abban az
  egy esetben fordulhat elõ, amikor $\gamma = \eta$, így
  kiegészíthetjük $\rightarrow$ definícióját, hogy ebben az esetben is
  fenn álljon a reláció.
\end{megj}

Egy adott $\rho$ gráfátíró rendszer mellett azt mondjuk, hogy $\gamma$
\emph{normál formájú}, ha nem található $\rho$-ban olyan szabály,
mely illeszkedik $\gamma$-ra, vagy valamelyik részgráfjára. Ez tehát
azt jelenti, hogy $\gamma$-nak $\rho$-ra nézve nincs
redexe. Figyeljük meg, hogy ahogy a redex tulajdonság is, úgy a
redexmentesség, tehát a normál forma is függ az adott $\rho$-tól. Azt
mondjuk, hogy $\gamma$-nak \emph{létezik normál formája}, ha van olyan
redukciós sorozat, mely $\gamma$-ból normál formát gyárt; más szóval,
ha $\gamma$-nak létezik normál formájú redukáltja.

Az adott $\rho$ gráfátíró rendszer mellett azt mondjuk, hogy $\gamma$
\emph{gyökér normál formájú}, ha $\gamma$ maga nem redex, és sosem
lesz az. Ez precízebben megfogalmazva azt jelenti, hogy bármilyen
redukciós sorozatát is véve $\gamma$-nak, a végeredmény sosem lesz
redex, azaz $\forall \gamma \rastar \eta: \eta~\text{nem
  redex}$. Ha egy gráf normál formájú, akkor gyökér normál formájú is,
de fordítva nem feltétlenül igaz; lehetnek olyan részgráfjai, melyek
redexek. Az a tény, hogy egy gráf sosem lesz redex, az általános
esetben eldönthetetlen, tehát a gyökér normál forma tulajdonság is
az. Sok esetben viszont triviálisan látszik, például azokban az
esetekben, amikor a gyökér egy konstruktor, mint a következõ példában:

\begin{pelda}
  Ebben a példában a Start gyökerû adatgráf gyökér normál formájú, mivel
  konstruktorral kezdõdik, azonban nincs normál formában, hiszen a
  Cons második paraméterétõl kezdõdõ részgráf egy redex. Rövid elemzés
  után azonban látható, hogy létezik normál formája, ez pedig
  Cons~3~120.

  \begin{shorthand}
    \con{Fact} 0 & 1 \\
    \con{Fact} $n$ & $*~n~(\con{Fact}~(-~n~1))$ \\
    \con{Start} & \con{Cons} 3 (\con{Fact} 5)
  \end{shorthand}
\end{pelda}

Mivel a mi szempontunkból nem teljesen nélkülözhetetlen eszközök, így
mindössze megemlítjük a következõ két
fogalmat. \told\Acite{cleanbook}+ban{} található a részletesebb
tárgyalásuk. Egy gráf \emph{részlegesen illeszkedik} egy szabályra, ha
a baloldalukat nézve elképzelhetõ, hogy pár redukciós lépés után
illeszkedni fognak. Egy gráf \emph{erõs normál formájú}, ha
részlegesen sem illeszkedik egyik szabályra sem. Az erõs normál forma
a gyökér normál formával ellentétben eldönthetõ tulajdonság. A
probléma ezekkel a fogalmakkal az (ahogy \cite{cleanbook} is említi),
hogy a következõhöz hasonló ciklikus esetekben nem definiáltak:

\begin{shorthand}
  \con{A} x & y \\
  \nl
  \con{Start} & A \con{Start}
\end{shorthand}

\subsection{Konfluencia}

Egy $\rho$ gráfátíró rendszer \emph{konfluens} (vagy
\emph{Church-Rosser tulajdonságú}) akkor és csak akkor, ha bármely két
(divergens) $\gamma \rastar \gamma_1$, $\gamma \rastar \gamma_2$
redukciós sorozatra létezik két (konvergens) $\gamma_1 \rastar \eta$,
$\gamma_2 \rastar \eta$ redukciós sorozat. A definíciót mutatja be
\aref{fig:konflu}. ábra. Ha $\rho$ konfluens, akkor
minden $\gamma$ adatgráfnak egyértelmûen létezik normál formája
$\rho$-ra nézve.

\begin{figure}[htb]
  \begin{center}
    \caption{A Church-Rosser tulajdonság \label{fig:konflu}}
    \includegraphics[height=0.3\textheight]{eps/konfluencia.eps}
  \end{center}
\end{figure}

Egy alapvetõen determinisztikus programozási nyelv szempontjából
kritikus az, hogy minden helyes kifejezés kiértékelése egyértelmû
eredményt adjon, így az
egyértelmû normál forma, és ennek kapcsán a konfluencia kívánatos
tulajdonságok. Term átíró rendszereknél két fontos gátja van a
konfluenciának; mivel ezek általánosításai a gráfátíró rendszerek, így
ezeket vizsgáljuk meg elõször.

\subsubsection{Többértelmûség}

A gráfátíró rendszerek szabályait vizsgáljuk ebben a részben. Két
különbözõ szabály  $\alpha_1$ és $\alpha_2$ bal oldalai \emph{teljesen
  átfedik egymást}, ha
létezik egy olyan adatgráf, mely mindkét baloldalnak
példánya. $\alpha_1$ és $\alpha_2$ \emph{részlegesen átfedik egymást},
ha létezik egy olyan adatgráf, mely $\alpha_1$-nek példánya,
$\alpha_2$ egy valódi (nem változó) részgráfjának példánya. Két ilyen
részlegesen átfedõ bal oldalt \emph{kritikus pár}nak is szokták
hívni. A jobb oldalak függvényében egy kritikus pár okozhatja a több
különbözõ normál forma létezését is. Ciklikus struktúráknál az is
elõfordulhat, hogy egy részgráf többféleképpen is illeszkedik
ugyanarra a részlegesen átfedõ szabályra.

\begin{pelda}
  A következõ példa a részleges átfedést mutatja be:

  \begin{shorthand}
    \con{f} (\con{g} $a$ 1) & 1 \\
    \con{g} $a$ $b$ & $a$
  \end{shorthand}

  A fenti átíró rendszerben a g 0 1 részgráf nyilván egy redex, és az
  elsõ szabály bal oldala egy nem változó részgráfjának példánya, így
  a két szabály részlegesen átfedi egymást. Ez azt jelenti, hogy
  például az f (g 0 1) adatgráf redukálható f 0-ra vagy 1-re is.

  Egy példa arra, hogyan illeszkedhet többféleképpen is egy részgráf a
  megfelelõ részlegesen átfedõ szabályra:

  \begin{canonGRS}
    r:~\con{F}~x, \\
    x:~\con{F}~a &\rightarrow~~r \leftarrow a \\
    \\
    \cn{1}&:~\con{F}~\cn{2}, \\
    \cn{2}&:~\con{F}~\cn{1}
  \end{canonGRS}

  Figyeljük meg, hogy az egyetlen szabály részlegesen átfedi önmagát
  (a részleges átfedésnél nem kötöttük ki azt, hogy $\alpha_1 \not =
  \alpha_2$).
  Az alsó adatgráf kétféleképpen illeszkedik a felsõ szabályra:
  egyrészt $\mu(r) = \cn{1}$, $\mu(x) = \cn{2}$, $\mu(a) = \cn{1}$, másrészt
  $\mu(r) = \cn{2}$, $\mu(x) = \cn{1}$, $\mu(a) = \cn{2}$.
\end{pelda}

Ez a többértelmûség tehát egy potenciális forrása a konfluencia
mentességnek, így ki kell küszöbölni a jelenséget. Szerencsére egy
triviális módosítással ez megoldható, mely az átíró rendszerek
lényegén nem változtat. Rendeljünk különbözõ prioritásokat a
szabályokhoz, és illesztésnél mindig a legkisebb (vagy legnagyobb,
definíció kérdése) prioritású szabályt próbáljuk elõször illeszteni. A
Haskell nyelvben például ezt a prioritást egyszerûen a szabályok
sorrendje adja. Illesztésnél mindig a forrás szövegben elõbb szereplõ
szabályt vesszük figyelembe elõször.

\subsubsection{Összehasonlítás}

Egy átírási szabály bal oldala \emph{összehasonlító} akkor és csak
akkor, ha létezik egy olyan változó csúcs azonosító, mely egynél
többször szerepel benne. Egy gráfátíró rendszer \emph{összehasonlító}
akkor és csak akkor, ha egy vagy több szabály bal oldala
összehasonlító. Ekkor az illesztésnél a csúcs azonosítók egyenlõségét
kell vizsgálni (összehasonlítani õket), és csak egyezés esetén
illeszkedhet a szabály. Ez sajnos a gyakorlatban nem használható jól,
mivel csak egy szintaktikai azonosságot vizsgálunk, de adott esetben
elõfordulhat, hogy két részgráf szintaktikailag nem, de szemantikailag
azonosak. A szemantikai azonosság viszont az általános esetben sajnos
algoritmikusan nem eldönthetõ. Természetesen vannak olyan esetek,
amikor ez eldönthetõ, például amikor a gráfok normál formában vannak
(ilyenkor a szintaktikai egyenlõség implikálja a szemantikai
azonosságot), de ez még nem elég a gyakorlati használhatóság
szavatolásához. A mi szempontunkból megközelítve, a Haskell nem engedi
meg a szabályok bal oldalán a duplikált változó elõfordulást, így ez
nem veszélyezteti a konfluenciát.

\begin{pelda}
  A következõ példa egy összehasonlító gráfátíró rendszert mutat be:

  \begin{shorthand}
    \con{isEqual} $x$ $x$ & \con{True}\\
    \nl
    \con{Start} & \con{isEqual} $2$ ($1+1$)
  \end{shorthand}

  Látható, hogy a start szimbólumra nem illeszkedik az egyetlen
  szabály, mivel a két argumentum szintaktikailag nem azonos.
\end{pelda}

\subsubsection{Önmagukat beágyazó redexek és a $\bot$}

Egy redex \emph{önmagát beágyazó}, ha a gyökerét magára kell
irányítani. Formálisan, léteznie kell egy $\mu$ leképezésnek a $r :
\alpha \rightarrow \beta, \varphi$ szabályhoz úgy, hogy a megfelelõ
$\mu''$ leképezést alkalmazva a $\varphi = n \leftarrow m$ redirekció
bal- és jobb oldalára, ugyanazt a konstans csúcs azonosítót kapjuk:
$\mu''(n) = \mu''(m)$. Így az ilyen redexek önmaguk redukáltjai. Az
alábbi példa bemutatja, hogy okozhat ez konfluencia-mentességet.

\begin{pelda}
  Legyenek a szabályaink a következõ alakúak:

  \begin{shorthand}
    \con{A} $x$ & $x$ \\
    \con{B} $x$ & $x$
  \end{shorthand}

  Ekkor a következõ gráf két redexet is tartalmaz:

  \begin{canonDG}
    \cn{1} & \con{G} \cn{2} \cn{3}, \\
    \cn{2} & \con{A} \cn{3}, \\
    \cn{3} & \con{B} \cn{2}
  \end{canonDG}

  Attól függõen, hogy elõször \con{A} szerint vagy \con{B} szerint
  redukálunk, a redukció után már csak a másik szabály szerint tudunk
  redukálni, de ez viszont már önmagát beágyazó redexet eredményez,
  melyet az átírás helyben hagy. Így tehát a két normál formája a
  fenti adatgráfnak:

  \begin{doubleDG}
    \multicolumn{2}{c}{Elõször \con{A} szerint redukálva} &
    \multicolumn{2}{c}{Elõször \con{B} szerint redukálva} \\
    \cn{1} & \con{G} \cn{3} \cn{3} & \cn{1} & \con{G} \cn{2} \cn{2} \\
    \cn{3} & \con{B} \cn{3}        & \cn{2} & \con{A} \cn{2}        \\
  \end{doubleDG}
\end{pelda}

Ennek a problémának az egyik megoldása az, hogy bevezetjük a speciális
$\bot$ konstans szimbólumot, és az önmagukat beágyazó redexeket egy
kivételes esetként kezelve az átírási folyamat negyedik (átirányítási)
lépésében erre a $\bot$-ra redukáljuk. Ezzel tulajdonképpen
definiáltuk az üres csúcs fogalmát, melyet tehát a $\bot$ szimbólum
jelképez, és angol neve \emph{bottom}. Ez a változtatás egyébként utat
nyit a gráfátíró rendszerek kategóriaelméleti tárgyalásának is, melyre
nyugodt szívvel mondhatjuk, hogy pozitív eredmény.

\subsection{Megosztás}

A gráfátíró rendszerek egyik jellegzetessége, ami az egyik oka a
kifejezõerejüknek a \emph{megosztás}. Ez annak a jelenségnek a neve,
amikor a szabályok jobb oldalán felhasználjuk a már kiszámított
eredményeinket, ezzel elkerülve a számítások többszörözését. A
megosztás (angolul \emph{sharing}) jellegzetessége, hogy a jobb
oldalon két vagy több helyen ugyanaz a változó csúcs azonosító
szerepel. A következõ példa \told\acite{cleanbook}+bol{} származik;
azt demonstrálja, hogyan lehet számítástudományi szempontból
``bonyolult'' példákat elegánsan megoldani ezzel a technikával.

\begin{pelda}
  Ebben a példában rendezett formában állítjuk elõ az összes $2^n3^m$
  alakú számot, ahol $n \text{ és } m \ge 0$. A megoldás Haskell-ben:

  \begin{lstlisting}
    hamm = let x = 1 : merge (map (*2) x) (map (*3) x) in x
    hamm' = ham' 1
        where
          ham' f = f : merge (ham' (f*2)) (ham' (f*3))

    merge []      []      = []
    merge f       []      = f
    merge []      s       = s
    merge f@(a:b) s@(c:d) = if a < c then
                                a : merge b s
                              else
                                if a == c then
                                   merge f d
                                else
                                   c : merge f d
  \end{lstlisting}

  Itt két különbözõ megoldást adtunk a problémára. Az elsõ
  (\emph{hamm}) megosztást használ a már eddig kiszámolt listaelemek
  újrahasznosítására, a második (\emph{hamm'}) pedig explicit
  rekurziót. A megosztást használó megoldás polinomiális idõben és
  tárhelyben fut, míg a másik mindkét szempontból exponenciális.
  A futtatási eredményeket mutatja a következõ (tipikus) GHCi kimenet:

  \begin{verbatim}
*Main> last $ take 200 hamm
15116544
(0.02 secs, 7377568 bytes)
*Main> last $ take 200 hamm'
15116544
(14.00 secs, 3187670248 bytes)
  \end{verbatim}

  Mindkét verzióval kiszámoltattuk a kétszázadik elemet a
  sorozatban. Az eredmény természetesen ugyanaz a nyolc jegyû szám, de
  a rekurziós verziónak ehhez 14 másodpercre, és körülbelül 3 gigabyte
  (!) memória allokálására volt szüksége, míg a megosztásos technikát
  használó változat mindössze két század másodperc alatt 7
  megabyte-nyi memória allokáció mellett tudta ugyanezt az eredményt
  produkálni.

  Érdekességképpen megadjuk a két fajta implementációhoz tartozó
  adatgráfok kanonikus alakját, illetve azok grafikus megjelenítését.

  \begin{doubleDG}
    \multicolumn{2}{c}{Megosztással} &
    \multicolumn{2}{c}{Rekurzióval} \\
    \cn{1} & \con{Cons} 1 \cn{2} & \cn{1} & \con{Cons} 1 \cn{2} \\
    \cn{2} & \con{Merge} \cn{3} \cn{4} & \cn{2} & \con{Merge} \cn{3} \cn{4}\\
    \cn{3} & \con{Map} \cn{5} \cn{1} & \cn{3} & \con{Ham'} \cn{5} \\
    \cn{4} & \con{Map} \cn{6} \cn{1} & \cn{4} & \con{Ham'} \cn{6} \\
    \cn{5} & * \cn{7} & \cn{5} & * \cn{7} \cn{8} \\
    \cn{6} & * \cn{8} & \cn{6} & * \cn{7} \cn{9} \\
    \cn{7} & 2 & \cn{7} & 1 \\
    \cn{8} & 3 & \cn{8} & 2 \\
    \multicolumn{2}{c}{} & \cn{9} & 3
  \end{doubleDG}

  A különbség jobban látszik, ha ábrázoljuk a két adatgráfot. Ahogy
  azt \aref{fig:hammrec} és \aref{fig:hammshar} ábrák is mutatják, a
  rekurziós esetben is kialakul egy megosztás (nevezetesen a Haskell
  kódban a \emph{ham'} függvény \emph{f} paraméterén, azaz az adatgráf
  esetében a \cn{7} csúcson), de ez nem ad lényeges gyorsítást az
  algoritmusnak, míg a másik verziónál a megosztás még ráadásul
  ciklikussá is teszi az adatgráfot.

  \begin{figure}[hb]
    \captionsetup{position=top}
    \captionsetup[subfloat]{captionskip=-20pt}
    \caption{Hamming számok listájának adatgráfjai}
    \begin{center}
      \subfloat[Hamming számok rekurzióval]{
        \label{fig:hammrec}
        \includegraphics[height=0.4\textheight]{eps/hamm_recurse.eps}
        \captionsetup{position=top}
      }
      \vrule
      \subfloat[Hamming számok megosztással]{
        \captionsetup{position=top}
        \label{fig:hammshar}
        \hspace{1cm}
        \includegraphics[height=0.4\textheight]{eps/hamm_share.eps}
      }
      \vspace{0.5cm}
    \end{center}
    \label{fig:hamm}
  \end{figure}

  \begin{megj}
    A példa az egyszerûség kedvéért nem sorolja fel az összes Hamming
    számot, csak a kettõvel vagy hárommal oszthatókat. Az összes
    reguláris szám felsorolásához egy három paraméteres \emph{merge}
    függvényt kellene definiálni, mely harmadik paraméterben az öttel
    is végig kellene szorozni a listánkat. Ezt a feladatot az olvasóra
    bízzuk.
  \end{megj}

\end{pelda}

\section{Redukciós stratégiák}

Legyen $\Theta$ a gráfátíró rendszerek, $\Gamma$ pedig az adatgráfok
halmaza. A $\sigma : \Theta \times \Gamma \rightarrow \Gamma$
függvényt \emph{redukciós stratégiá}nak nevezzük, ha adott $\rho \in
\Theta$ gráfátíró rendszer és $\gamma_0 \in \Gamma$ adatgráf esetén
$\forall \gamma \in \sigma(\rho, \gamma_0): \gamma \text{ redex }
\gamma_0\text{-ban } \rho\text{-ra nézve}$. A $\sigma$ megadja, hogy
egy adott adatgráf (és átíró rendszer) esetén melyik redexre hajtsunk
végre elõször átírási lépést. Ha $\exists \rho \in \Theta, \gamma_0
\in \Gamma : |\sigma(\rho, \gamma_0)| > 1$, akkor a $\sigma$ egy
nemdeterminisztikus redukciós stratégia. Ekkor tetszõleges sorrendben
redukálhatjuk a $\sigma$ által megadott redexeket. Léteznek olyan
redukciós stratégiák, melyek több redexet is megadnak párhuzamos
redukálásra. Ezeket párhuzamos redukciós stratégiáknak hívják, de
ebben a diplomamunkában ilyen típusúakkal nem foglalkozunk.

A \emph{redukáló} egy olyan folyamat, ami egy meghatározott stratégia
szerint sorra redukálja a redexeket. A folyamat véget ér, amint a
redukciós stratégia nem ad vissza redukálható redexet. Egy redukciós
stratégia \emph{normalizáló} akkor és csak akkor, ha bármilyen
$\gamma$ adatgráfra, melynek létezik normál formája, az a
redukáló folyamat, mely ezt a stratégiát követi és $\gamma$-ból indul,
normál formával terminál. Egy $\sigma$ redukciós stratégia
\emph{hipernormalizáló} akkor és csak akkor, ha annak ellenére, hogy
a $\sigma$-tól \textbf{véges számú} tetszõleges redukciós lépéssel
eltérünk, még mindig normalizáló marad. Ez a fogalom különösen fontos
az esetünkben, mert lehetõséget ad pár lépés erejéig eltérni a
szokásos redukciós stratégiától. Ez nagyon hasznos például
hiba-követés vagy optimalizálás esetén.

Sajnos nem létezik normalizáló stratégia egy tetszõleges gráfátíró
rendszer esetén, ezért csak olyan speciális, konfluens rendszereket
nézünk, melyek jól viselkednek ebbõl a szempontból. Több érdekes
osztályuk van a gráfátíró rendszereknek, egy részüket a termek
átírásáért felelõs rendszerekbõl lehet kiegészíteni gráfátíró
rendszerekké. Mi most egy ilyen osztályt vizsgálunk meg, de ehhez
elõbb egy speciális redukciós stratégiát ismertetünk.

\subsection{Funkcionális redukciós stratégia}

A \emph{funkcionális redukciós stratégia} célja egy egyszerûen
átlátható, de ugyanakkor hatékony algoritmus meghatározása a redexek
kiértékelésének sorrendjére. Ezt a stratégiát használja a legtöbb
funkcionális nyelv, pont az elõbbi két tulajdonság miatt. Az
algoritmus a következõ: ha több átírási szabály van egy adott
függvényre, a szabályokat a definiálásuk sorrendjében ``fentrõl
lefelé'' próbáljuk; a mintákat ``balról jobbra'', sorrendben próbáljuk
illeszteni; és ha az aktuális argumentumnak egy nem-változó mintára
kell illeszkednie, akkor ezt az argumentumot mindenképpen kiértékeljük
(\emph{a kiértékelés erõltetése})
mintaillesztés elõtt (ez a folyamat részlegesen illeszkedõ szabályok
esetén is). Ha a kiértékelés után a mintaillesztés sikeres, akkor
folytatjuk a következõ pozíción található argumentummal egészen addig,
amíg az egész szabály nem illeszkedik (vagy az egyik mintaillesztés
nem sikerül). Amennyiben az egyik mintaillesztés sikertelen, úgy
próbáljuk a következõ szabály bal oldalát illeszteni \textbf{az így
  kialakult kifejezésre} (tehát a kiértékelések eredményét nem dobjuk
el). Ha egyik szabályt sem tudjuk alkalmazni, a gráfunk (erõs) gyökér
normál formában van. Amennyiben normál formát követelünk meg a
stratégiától, úgy a kialakult gyökér normál formák részgráfjaira
rekurzívan alkalmazzuk a stratégiát.

A funkcionális redukciós stratégia tehát egy gyakorlati kompromisszum
eredménye: hatékonyan implementálható, és a számításokat könnyen
érthetõen lehet vele kifejezni. További elõnye, hogy könnyû
elmagyarázni a mûködését, nem operál bonyolult fogalmakkal, könnyen
használható -- a szabályokhoz rendelt implicit prioritás nagyon
hasonlít a programozási nyelvekben szokásos \emph{if \ldots then
  \ldots else} konstrukcióra.

\section{Funkcionális gráfátíró rendszerek}

A funkcionális gráfátíró rendszerek alapjait a hasonló nevû
funkcionális term átíró rendszerek kiegészítéseként kapjuk. Általában
az elõzõ részben definiált funkcionális redukciós stratégia értelmében
prioritásokat rendelünk az egyes szabályokhoz; egy illeszkedõ szabályt
csak akkor választhatunk a redukciós lépéshez, ha a magasabb
prioritású szabályok sosem fognak illeszkedni az (illesztés közben
esetleg módosult, átírt) adatgráfra. Sajnos az általános esetben
algoritmikusan nem eldönthetõ az, hogy egy gráf valaha illeszkedni
fog-e egy adott mintára a belsõ átírások következményeként, de a
kiértékelés erõltetése elõbb-utóbb egy olyan helyzethez vezet, amiben
már ezt a kérdést el lehet dönteni. Egyetlen probléma van ezzel az
erõltetéssel: ennek okaként elképzelhetõ, hogy a kiértékelés sosem fog
terminálni, pedig szemantikailag ez elkerülhetõ lenne.

Ez a stratégia a funkcionális gráfátíró rendszerek lényeges többségére
normalizáló. Ha csak olyan eltérõ lépéseket teszünk a stratégiától,
mely a prioritási szabályoknak megfelel, akkor ez a redukciós
stratégia még hipernormalizáló is ezekre az átíró rendszerekre
(részletekért lásd a következõket: \cite{cleanbook}, \cite{funcstrat})

%% Local Variables:
%% coding: latin-2
%% End:

% LocalWords:  CanonicalGRS Rule RedexPattern Contractum Redirection StartNode
% LocalWords:  ContractumPattern GraphRewriteSystem Nat Succ rule rwrredir bol
% LocalWords:  cleanbook isEqual let merge map in ham where if then else GHCi
% LocalWords:  hammrec hammshar position subfloat captionskip pt stratégiá
